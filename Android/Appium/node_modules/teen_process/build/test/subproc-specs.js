require('source-map-support').install();

'use strict';

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _Promise = require('babel-runtime/core-js/promise')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

var _this = this;

var _bluebird = require('bluebird');

var _bluebird2 = _interopRequireDefault(_bluebird);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _ = require('..');

var _chai = require('chai');

var _chai2 = _interopRequireDefault(_chai);

var _chaiAsPromised = require('chai-as-promised');

var _chaiAsPromised2 = _interopRequireDefault(_chaiAsPromised);

var _helpers = require('./helpers');

var _appiumSupport = require('appium-support');

// Windows doesn't understand SIGHUP
var stopSignal = _appiumSupport.system.isWindows() ? 'SIGTERM' : 'SIGHUP';
var should = _chai2['default'].should();
_chai2['default'].use(_chaiAsPromised2['default']);

describe('SubProcess', function () {
  it('should throw an error if initialized without a command', function () {
    should['throw'](function () {
      new _.SubProcess();
    });
  });
  it('should throw an error if initialized with a bad command', function () {
    should['throw'](function () {
      new _.SubProcess({ lol: true });
    });
    should['throw'](function () {
      new _.SubProcess(1);
    });
  });
  it('should throw an error if initialized with bad args', function () {
    should['throw'](function () {
      new _.SubProcess('ls', 'foo');
    });
    should['throw'](function () {
      new _.SubProcess('ls', 1);
    });
    should['throw'](function () {
      new _.SubProcess('ls', {});
    });
  });
  it('should default args list to []', function () {
    var x = new _.SubProcess('ls');
    x.args.should.eql([]);
  });
  it('should default opts dict to {}', function () {
    var x = new _.SubProcess('ls');
    x.opts.should.eql({});
  });
  it('should pass opts to spawn', function callee$1$0() {
    var cwd, subproc, lines;
    return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          cwd = _path2['default'].resolve((0, _helpers.getFixture)('.'));
          subproc = new _.SubProcess('ls', [], { cwd: cwd });
          lines = [];

          subproc.on('lines-stdout', function (newLines) {
            lines = lines.concat(newLines);
          });
          context$2$0.next = 6;
          return _regeneratorRuntime.awrap(subproc.start(0));

        case 6:
          context$2$0.next = 8;
          return _regeneratorRuntime.awrap(_bluebird2['default'].delay(50));

        case 8:
          lines.should.include('bad_exit.sh');
          lines.should.contain('bigbuffer.js');
          lines.should.contain('echo.sh');

        case 11:
        case 'end':
          return context$2$0.stop();
      }
    }, null, _this);
  });

  describe('#start', function () {
    it('should throw an error if command fails on startup', function callee$2$0() {
      var s;
      return _regeneratorRuntime.async(function callee$2$0$(context$3$0) {
        while (1) switch (context$3$0.prev = context$3$0.next) {
          case 0:
            s = new _.SubProcess('blargimarg');
            context$3$0.next = 3;
            return _regeneratorRuntime.awrap(s.start().should.eventually.be.rejectedWith(/not found/));

          case 3:
          case 'end':
            return context$3$0.stop();
        }
      }, null, _this);
    });
    it('should have a default startDetector of waiting for output', function callee$2$0() {
      var hasData, s;
      return _regeneratorRuntime.async(function callee$2$0$(context$3$0) {
        while (1) switch (context$3$0.prev = context$3$0.next) {
          case 0:
            hasData = false;
            s = new _.SubProcess('ls');

            s.on('output', function (stdout) {
              if (stdout) {
                hasData = true;
              }
            });
            context$3$0.next = 5;
            return _regeneratorRuntime.awrap(s.start());

          case 5:
            hasData.should.be['true'];

          case 6:
          case 'end':
            return context$3$0.stop();
        }
      }, null, _this);
    });
    it('should interpret a numeric startDetector as a start timeout', function callee$2$0() {
      var hasData, s;
      return _regeneratorRuntime.async(function callee$2$0$(context$3$0) {
        while (1) switch (context$3$0.prev = context$3$0.next) {
          case 0:
            hasData = false;
            s = new _.SubProcess((0, _helpers.getFixture)('sleepyproc'), ['ls']);

            s.on('output', function (stdout) {
              if (stdout) {
                hasData = true;
              }
            });
            context$3$0.next = 5;
            return _regeneratorRuntime.awrap(s.start(0));

          case 5:
            hasData.should.be['false'];
            context$3$0.next = 8;
            return _regeneratorRuntime.awrap(_bluebird2['default'].delay(1200));

          case 8:
            hasData.should.be['true'];

          case 9:
          case 'end':
            return context$3$0.stop();
        }
      }, null, _this);
    });
    it('should fail even with a start timeout of 0 when command is bad', function callee$2$0() {
      var s;
      return _regeneratorRuntime.async(function callee$2$0$(context$3$0) {
        while (1) switch (context$3$0.prev = context$3$0.next) {
          case 0:
            s = new _.SubProcess('blargimarg');
            context$3$0.next = 3;
            return _regeneratorRuntime.awrap(s.start(0).should.eventually.be.rejectedWith(/not found/));

          case 3:
          case 'end':
            return context$3$0.stop();
        }
      }, null, _this);
    });
    it('should be able to provide a custom startDetector function', function callee$2$0() {
      var sd, hasData, s;
      return _regeneratorRuntime.async(function callee$2$0$(context$3$0) {
        while (1) switch (context$3$0.prev = context$3$0.next) {
          case 0:
            sd = function sd(stdout) {
              return stdout;
            };

            hasData = false;
            s = new _.SubProcess('ls');

            s.on('output', function (stdout) {
              if (stdout) {
                hasData = true;
              }
            });
            context$3$0.next = 6;
            return _regeneratorRuntime.awrap(s.start(sd));

          case 6:
            hasData.should.be['true'];

          case 7:
          case 'end':
            return context$3$0.stop();
        }
      }, null, _this);
    });
    it('should pass on custom errors from startDetector', function callee$2$0() {
      var sd, s;
      return _regeneratorRuntime.async(function callee$2$0$(context$3$0) {
        while (1) switch (context$3$0.prev = context$3$0.next) {
          case 0:
            sd = function sd() {
              throw new Error('foo');
            };

            s = new _.SubProcess('ls');
            context$3$0.next = 4;
            return _regeneratorRuntime.awrap(s.start(sd).should.eventually.be.rejectedWith(/foo/));

          case 4:
          case 'end':
            return context$3$0.stop();
        }
      }, null, _this);
    });
    it('should time out starts that take longer than specified ms', function callee$2$0() {
      var sd, s, start;
      return _regeneratorRuntime.async(function callee$2$0$(context$3$0) {
        while (1) switch (context$3$0.prev = context$3$0.next) {
          case 0:
            sd = function sd(stdout) {
              return stdout.indexOf('nothere') !== -1;
            };

            s = new _.SubProcess('ls');
            start = Date.now();
            context$3$0.next = 5;
            return _regeneratorRuntime.awrap(s.start(sd, 500).should.eventually.be.rejectedWith(/did not start.+time/i));

          case 5:
            (Date.now() - start).should.be.below(600);

          case 6:
          case 'end':
            return context$3$0.stop();
        }
      }, null, _this);
    });
  });

  describe('listening for data', function () {
    var subproc = undefined;
    it('should get output as params', function callee$2$0() {
      return _regeneratorRuntime.async(function callee$2$0$(context$3$0) {
        var _this2 = this;

        while (1) switch (context$3$0.prev = context$3$0.next) {
          case 0:
            context$3$0.next = 2;
            return _regeneratorRuntime.awrap(new _Promise(function callee$3$0(resolve) {
              return _regeneratorRuntime.async(function callee$3$0$(context$4$0) {
                while (1) switch (context$4$0.prev = context$4$0.next) {
                  case 0:
                    subproc = new _.SubProcess((0, _helpers.getFixture)('sleepyproc'), ['ls', _path2['default'].resolve(__dirname)]);
                    subproc.on('output', function (stdout) {
                      if (stdout && stdout.indexOf('subproc-specs') !== -1) {
                        resolve();
                      }
                    });
                    context$4$0.next = 4;
                    return _regeneratorRuntime.awrap(subproc.start());

                  case 4:
                  case 'end':
                    return context$4$0.stop();
                }
              }, null, _this2);
            }));

          case 2:
            context$3$0.next = 4;
            return _regeneratorRuntime.awrap(subproc.stop());

          case 4:
            context$3$0.next = 6;
            return _regeneratorRuntime.awrap(new _Promise(function callee$3$0(resolve) {
              return _regeneratorRuntime.async(function callee$3$0$(context$4$0) {
                while (1) switch (context$4$0.prev = context$4$0.next) {
                  case 0:
                    subproc = new _.SubProcess((0, _helpers.getFixture)('echo'), ['foo', 'bar']);
                    subproc.on('output', function (stdout, stderr) {
                      if (stderr && stderr.indexOf('bar') !== -1) {
                        resolve();
                      }
                    });
                    context$4$0.next = 4;
                    return _regeneratorRuntime.awrap(subproc.start());

                  case 4:
                  case 'end':
                    return context$4$0.stop();
                }
              }, null, _this2);
            }));

          case 6:
            context$3$0.next = 8;
            return _regeneratorRuntime.awrap(subproc.stop());

          case 8:
          case 'end':
            return context$3$0.stop();
        }
      }, null, _this);
    });

    it('should get output by lines', function callee$2$0() {
      var lines;
      return _regeneratorRuntime.async(function callee$2$0$(context$3$0) {
        while (1) switch (context$3$0.prev = context$3$0.next) {
          case 0:
            subproc = new _.SubProcess('ls', [_path2['default'].resolve(__dirname)]);
            lines = [];

            subproc.on('lines-stdout', function (newLines) {
              lines = lines.concat(newLines);
            });
            context$3$0.next = 5;
            return _regeneratorRuntime.awrap(subproc.start(0));

          case 5:
            context$3$0.next = 7;
            return _regeneratorRuntime.awrap(_bluebird2['default'].delay(50));

          case 7:
            lines.should.eql(['exec-specs.js', 'fixtures', 'helpers.js', 'subproc-specs.js']);

          case 8:
          case 'end':
            return context$3$0.stop();
        }
      }, null, _this);
    });
  });

  describe('#stop', function () {
    it('should send the right signal to stop a proc', function callee$2$0() {
      return _regeneratorRuntime.async(function callee$2$0$(context$3$0) {
        var _this3 = this;

        while (1) switch (context$3$0.prev = context$3$0.next) {
          case 0:
            return context$3$0.abrupt('return', new _Promise(function callee$3$0(resolve, reject) {
              var subproc;
              return _regeneratorRuntime.async(function callee$3$0$(context$4$0) {
                while (1) switch (context$4$0.prev = context$4$0.next) {
                  case 0:
                    subproc = new _.SubProcess('tail', ['-f', _path2['default'].resolve(__filename)]);
                    context$4$0.next = 3;
                    return _regeneratorRuntime.awrap(subproc.start());

                  case 3:
                    subproc.on('exit', function (code, signal) {
                      try {
                        signal.should.equal(stopSignal);
                        resolve();
                      } catch (e) {
                        reject(e);
                      }
                    });
                    context$4$0.next = 6;
                    return _regeneratorRuntime.awrap(subproc.stop(stopSignal));

                  case 6:
                  case 'end':
                    return context$4$0.stop();
                }
              }, null, _this3);
            }));

          case 1:
          case 'end':
            return context$3$0.stop();
        }
      }, null, _this);
    });

    it('should time out if stop doesnt complete fast enough', function callee$2$0() {
      var subproc;
      return _regeneratorRuntime.async(function callee$2$0$(context$3$0) {
        while (1) switch (context$3$0.prev = context$3$0.next) {
          case 0:
            subproc = new _.SubProcess((0, _helpers.getFixture)('traphup'), ['tail', '-f', _path2['default'].resolve(__filename)]);
            context$3$0.next = 3;
            return _regeneratorRuntime.awrap(subproc.start());

          case 3:
            context$3$0.next = 5;
            return _regeneratorRuntime.awrap(subproc.stop(stopSignal, 1).should.eventually.be.rejectedWith(/Process didn't end/));

          case 5:
            context$3$0.prev = 5;
            context$3$0.next = 8;
            return _regeneratorRuntime.awrap((0, _.exec)('kill', ['-9', subproc.proc.pid + 1]));

          case 8:
            context$3$0.next = 12;
            break;

          case 10:
            context$3$0.prev = 10;
            context$3$0.t0 = context$3$0['catch'](5);

          case 12:
            context$3$0.prev = 12;
            context$3$0.next = 15;
            return _regeneratorRuntime.awrap((0, _.exec)('kill', ['-9', subproc.proc.pid]));

          case 15:
            context$3$0.next = 19;
            break;

          case 17:
            context$3$0.prev = 17;
            context$3$0.t1 = context$3$0['catch'](12);

          case 19:
          case 'end':
            return context$3$0.stop();
        }
      }, null, _this, [[5, 10], [12, 17]]);
    });

    it('should error if there is no process to stop', function callee$2$0() {
      var subproc;
      return _regeneratorRuntime.async(function callee$2$0$(context$3$0) {
        while (1) switch (context$3$0.prev = context$3$0.next) {
          case 0:
            subproc = new _.SubProcess('ls');
            context$3$0.next = 3;
            return _regeneratorRuntime.awrap(subproc.stop().should.eventually.be.rejectedWith(/Can't stop/));

          case 3:
            context$3$0.next = 5;
            return _regeneratorRuntime.awrap(subproc.start());

          case 5:
            context$3$0.next = 7;
            return _regeneratorRuntime.awrap(_bluebird2['default'].delay(10));

          case 7:
            context$3$0.next = 9;
            return _regeneratorRuntime.awrap(subproc.stop().should.eventually.be.rejectedWith(/Can't stop/));

          case 9:
          case 'end':
            return context$3$0.stop();
        }
      }, null, _this);
    });
  });

  describe('#join', function () {
    it('should fail if the #start has not yet been called', function callee$2$0() {
      var proc;
      return _regeneratorRuntime.async(function callee$2$0$(context$3$0) {
        while (1) switch (context$3$0.prev = context$3$0.next) {
          case 0:
            proc = new _.SubProcess((0, _helpers.getFixture)('sleepyproc.sh'), ['ls']);
            context$3$0.next = 3;
            return _regeneratorRuntime.awrap(proc.join().should.eventually.be.rejectedWith(/Can't join/));

          case 3:
          case 'end':
            return context$3$0.stop();
        }
      }, null, _this);
    });

    it('should wait until the process has been finished', function callee$2$0() {
      var proc, now, diff;
      return _regeneratorRuntime.async(function callee$2$0$(context$3$0) {
        while (1) switch (context$3$0.prev = context$3$0.next) {
          case 0:
            proc = new _.SubProcess((0, _helpers.getFixture)('sleepyproc'), ['ls']);
            now = Date.now();
            context$3$0.next = 4;
            return _regeneratorRuntime.awrap(proc.start(0));

          case 4:
            context$3$0.next = 6;
            return _regeneratorRuntime.awrap(proc.join());

          case 6:
            diff = Date.now() - now;

            diff.should.be.above(1000);

          case 8:
          case 'end':
            return context$3$0.stop();
        }
      }, null, _this);
    });

    it('should throw if process ends with a invalid exitcode', function callee$2$0() {
      var proc;
      return _regeneratorRuntime.async(function callee$2$0$(context$3$0) {
        while (1) switch (context$3$0.prev = context$3$0.next) {
          case 0:
            proc = new _.SubProcess((0, _helpers.getFixture)('bad_exit'));
            context$3$0.next = 3;
            return _regeneratorRuntime.awrap(proc.start(0));

          case 3:
            context$3$0.next = 5;
            return _regeneratorRuntime.awrap(proc.join().should.eventually.be.rejectedWith(/Process ended with exitcode/));

          case 5:
          case 'end':
            return context$3$0.stop();
        }
      }, null, _this);
    });

    it('should NOT throw if process ends with a custom allowed exitcode', function callee$2$0() {
      var proc;
      return _regeneratorRuntime.async(function callee$2$0$(context$3$0) {
        while (1) switch (context$3$0.prev = context$3$0.next) {
          case 0:
            proc = new _.SubProcess((0, _helpers.getFixture)('bad_exit'));
            context$3$0.next = 3;
            return _regeneratorRuntime.awrap(proc.start(0));

          case 3:
            context$3$0.next = 5;
            return _regeneratorRuntime.awrap(proc.join([1]).should.eventually.be.become(1));

          case 5:
          case 'end':
            return context$3$0.stop();
        }
      }, null, _this);
    });
  });
});

// need to kill the process
// 1 for the trap, 1 for the tail
//# sourceMappingURL=data:application/json;charset=utf8;base64,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LENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQzs7Ozs2Q0FDYixJQUFJLENBQUMsSUFBSSxFQUFFOzs7QUFDWCxnQkFBSSxHQUFHLElBQUksQ0FBQyxHQUFHLEVBQUUsR0FBRyxHQUFHOztBQUM3QixnQkFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDOzs7Ozs7O0tBQzVCLENBQUMsQ0FBQzs7QUFFSCxNQUFFLENBQUMsc0RBQXNELEVBQUU7VUFDbkQsSUFBSTs7OztBQUFKLGdCQUFJLEdBQUcsaUJBQWUseUJBQVcsVUFBVSxDQUFDLENBQUM7OzZDQUM3QyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQzs7Ozs2Q0FDYixJQUFJLENBQUMsSUFBSSxFQUFFLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxFQUFFLENBQUMsWUFBWSxDQUFDLDZCQUE2QixDQUFDOzs7Ozs7O0tBQ25GLENBQUMsQ0FBQzs7QUFFSCxNQUFFLENBQUMsaUVBQWlFLEVBQUU7VUFDOUQsSUFBSTs7OztBQUFKLGdCQUFJLEdBQUcsaUJBQWUseUJBQVcsVUFBVSxDQUFDLENBQUM7OzZDQUM3QyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQzs7Ozs2Q0FDYixJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLEVBQUUsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDOzs7Ozs7O0tBQ3BELENBQUMsQ0FBQztHQUNKLENBQUMsQ0FBQztDQUNKLENBQUMsQ0FBQyIsImZpbGUiOiJ0ZXN0L3N1YnByb2Mtc3BlY3MuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyB0cmFuc3BpbGU6bW9jaGFcblxuaW1wb3J0IEIgZnJvbSAnYmx1ZWJpcmQnO1xuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgeyBleGVjLCBTdWJQcm9jZXNzIH0gZnJvbSAnLi4nO1xuaW1wb3J0IGNoYWkgZnJvbSAnY2hhaSc7XG5pbXBvcnQgY2hhaUFzUHJvbWlzZWQgZnJvbSAnY2hhaS1hcy1wcm9taXNlZCc7XG5pbXBvcnQgeyBnZXRGaXh0dXJlIH0gZnJvbSAnLi9oZWxwZXJzJztcbmltcG9ydCB7IHN5c3RlbSB9IGZyb20gJ2FwcGl1bS1zdXBwb3J0JztcblxuXG4vLyBXaW5kb3dzIGRvZXNuJ3QgdW5kZXJzdGFuZCBTSUdIVVBcbmxldCBzdG9wU2lnbmFsID0gc3lzdGVtLmlzV2luZG93cygpID8gJ1NJR1RFUk0nIDogJ1NJR0hVUCc7XG5jb25zdCBzaG91bGQgPSBjaGFpLnNob3VsZCgpO1xuY2hhaS51c2UoY2hhaUFzUHJvbWlzZWQpO1xuXG5kZXNjcmliZSgnU3ViUHJvY2VzcycsICgpID0+IHtcbiAgaXQoJ3Nob3VsZCB0aHJvdyBhbiBlcnJvciBpZiBpbml0aWFsaXplZCB3aXRob3V0IGEgY29tbWFuZCcsICgpID0+IHtcbiAgICBzaG91bGQudGhyb3coKCkgPT4ge1xuICAgICAgbmV3IFN1YlByb2Nlc3MoKTtcbiAgICB9KTtcbiAgfSk7XG4gIGl0KCdzaG91bGQgdGhyb3cgYW4gZXJyb3IgaWYgaW5pdGlhbGl6ZWQgd2l0aCBhIGJhZCBjb21tYW5kJywgKCkgPT4ge1xuICAgIHNob3VsZC50aHJvdygoKSA9PiB7XG4gICAgICBuZXcgU3ViUHJvY2Vzcyh7bG9sOiB0cnVlfSk7XG4gICAgfSk7XG4gICAgc2hvdWxkLnRocm93KCgpID0+IHtcbiAgICAgIG5ldyBTdWJQcm9jZXNzKDEpO1xuICAgIH0pO1xuICB9KTtcbiAgaXQoJ3Nob3VsZCB0aHJvdyBhbiBlcnJvciBpZiBpbml0aWFsaXplZCB3aXRoIGJhZCBhcmdzJywgKCkgPT4ge1xuICAgIHNob3VsZC50aHJvdygoKSA9PiB7XG4gICAgICBuZXcgU3ViUHJvY2VzcygnbHMnLCAnZm9vJyk7XG4gICAgfSk7XG4gICAgc2hvdWxkLnRocm93KCgpID0+IHtcbiAgICAgIG5ldyBTdWJQcm9jZXNzKCdscycsIDEpO1xuICAgIH0pO1xuICAgIHNob3VsZC50aHJvdygoKSA9PiB7XG4gICAgICBuZXcgU3ViUHJvY2VzcygnbHMnLCB7fSk7XG4gICAgfSk7XG4gIH0pO1xuICBpdCgnc2hvdWxkIGRlZmF1bHQgYXJncyBsaXN0IHRvIFtdJywgKCkgPT4ge1xuICAgIGxldCB4ID0gbmV3IFN1YlByb2Nlc3MoJ2xzJyk7XG4gICAgeC5hcmdzLnNob3VsZC5lcWwoW10pO1xuICB9KTtcbiAgaXQoJ3Nob3VsZCBkZWZhdWx0IG9wdHMgZGljdCB0byB7fScsICgpID0+IHtcbiAgICBsZXQgeCA9IG5ldyBTdWJQcm9jZXNzKCdscycpO1xuICAgIHgub3B0cy5zaG91bGQuZXFsKHt9KTtcbiAgfSk7XG4gIGl0KCdzaG91bGQgcGFzcyBvcHRzIHRvIHNwYXduJywgYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IGN3ZCA9IHBhdGgucmVzb2x2ZShnZXRGaXh0dXJlKCcuJykpO1xuICAgIGNvbnN0IHN1YnByb2MgPSBuZXcgU3ViUHJvY2VzcygnbHMnLCBbXSwge2N3ZH0pO1xuICAgIGxldCBsaW5lcyA9IFtdO1xuICAgIHN1YnByb2Mub24oJ2xpbmVzLXN0ZG91dCcsIChuZXdMaW5lcykgPT4ge1xuICAgICAgbGluZXMgPSBsaW5lcy5jb25jYXQobmV3TGluZXMpO1xuICAgIH0pO1xuICAgIGF3YWl0IHN1YnByb2Muc3RhcnQoMCk7XG4gICAgYXdhaXQgQi5kZWxheSg1MCk7XG4gICAgbGluZXMuc2hvdWxkLmluY2x1ZGUoJ2JhZF9leGl0LnNoJyk7XG4gICAgbGluZXMuc2hvdWxkLmNvbnRhaW4oJ2JpZ2J1ZmZlci5qcycpO1xuICAgIGxpbmVzLnNob3VsZC5jb250YWluKCdlY2hvLnNoJyk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCcjc3RhcnQnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCB0aHJvdyBhbiBlcnJvciBpZiBjb21tYW5kIGZhaWxzIG9uIHN0YXJ0dXAnLCBhc3luYyAoKSA9PiB7XG4gICAgICBsZXQgcyA9IG5ldyBTdWJQcm9jZXNzKCdibGFyZ2ltYXJnJyk7XG4gICAgICBhd2FpdCBzLnN0YXJ0KCkuc2hvdWxkLmV2ZW50dWFsbHkuYmUucmVqZWN0ZWRXaXRoKC9ub3QgZm91bmQvKTtcbiAgICB9KTtcbiAgICBpdCgnc2hvdWxkIGhhdmUgYSBkZWZhdWx0IHN0YXJ0RGV0ZWN0b3Igb2Ygd2FpdGluZyBmb3Igb3V0cHV0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgbGV0IGhhc0RhdGEgPSBmYWxzZTtcbiAgICAgIGxldCBzID0gbmV3IFN1YlByb2Nlc3MoJ2xzJyk7XG4gICAgICBzLm9uKCdvdXRwdXQnLCAoc3Rkb3V0KSA9PiB7XG4gICAgICAgIGlmIChzdGRvdXQpIHtcbiAgICAgICAgICBoYXNEYXRhID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBhd2FpdCBzLnN0YXJ0KCk7XG4gICAgICBoYXNEYXRhLnNob3VsZC5iZS50cnVlO1xuICAgIH0pO1xuICAgIGl0KCdzaG91bGQgaW50ZXJwcmV0IGEgbnVtZXJpYyBzdGFydERldGVjdG9yIGFzIGEgc3RhcnQgdGltZW91dCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGxldCBoYXNEYXRhID0gZmFsc2U7XG4gICAgICBsZXQgcyA9IG5ldyBTdWJQcm9jZXNzKGdldEZpeHR1cmUoJ3NsZWVweXByb2MnKSwgWydscyddKTtcbiAgICAgIHMub24oJ291dHB1dCcsIChzdGRvdXQpID0+IHtcbiAgICAgICAgaWYgKHN0ZG91dCkge1xuICAgICAgICAgIGhhc0RhdGEgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGF3YWl0IHMuc3RhcnQoMCk7XG4gICAgICBoYXNEYXRhLnNob3VsZC5iZS5mYWxzZTtcbiAgICAgIGF3YWl0IEIuZGVsYXkoMTIwMCk7XG4gICAgICBoYXNEYXRhLnNob3VsZC5iZS50cnVlO1xuICAgIH0pO1xuICAgIGl0KCdzaG91bGQgZmFpbCBldmVuIHdpdGggYSBzdGFydCB0aW1lb3V0IG9mIDAgd2hlbiBjb21tYW5kIGlzIGJhZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGxldCBzID0gbmV3IFN1YlByb2Nlc3MoJ2JsYXJnaW1hcmcnKTtcbiAgICAgIGF3YWl0IHMuc3RhcnQoMCkuc2hvdWxkLmV2ZW50dWFsbHkuYmUucmVqZWN0ZWRXaXRoKC9ub3QgZm91bmQvKTtcbiAgICB9KTtcbiAgICBpdCgnc2hvdWxkIGJlIGFibGUgdG8gcHJvdmlkZSBhIGN1c3RvbSBzdGFydERldGVjdG9yIGZ1bmN0aW9uJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbGV0IHNkID0gKHN0ZG91dCkgPT4geyByZXR1cm4gc3Rkb3V0OyB9O1xuICAgICAgbGV0IGhhc0RhdGEgPSBmYWxzZTtcbiAgICAgIGxldCBzID0gbmV3IFN1YlByb2Nlc3MoJ2xzJyk7XG4gICAgICBzLm9uKCdvdXRwdXQnLCAoc3Rkb3V0KSA9PiB7XG4gICAgICAgIGlmIChzdGRvdXQpIHtcbiAgICAgICAgICBoYXNEYXRhID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBhd2FpdCBzLnN0YXJ0KHNkKTtcbiAgICAgIGhhc0RhdGEuc2hvdWxkLmJlLnRydWU7XG4gICAgfSk7XG4gICAgaXQoJ3Nob3VsZCBwYXNzIG9uIGN1c3RvbSBlcnJvcnMgZnJvbSBzdGFydERldGVjdG9yJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbGV0IHNkID0gKCkgPT4geyB0aHJvdyBuZXcgRXJyb3IoJ2ZvbycpOyB9O1xuICAgICAgbGV0IHMgPSBuZXcgU3ViUHJvY2VzcygnbHMnKTtcbiAgICAgIGF3YWl0IHMuc3RhcnQoc2QpLnNob3VsZC5ldmVudHVhbGx5LmJlLnJlamVjdGVkV2l0aCgvZm9vLyk7XG4gICAgfSk7XG4gICAgaXQoJ3Nob3VsZCB0aW1lIG91dCBzdGFydHMgdGhhdCB0YWtlIGxvbmdlciB0aGFuIHNwZWNpZmllZCBtcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGxldCBzZCA9IChzdGRvdXQpID0+IHsgcmV0dXJuIHN0ZG91dC5pbmRleE9mKCdub3RoZXJlJykgIT09IC0xOyB9O1xuICAgICAgbGV0IHMgPSBuZXcgU3ViUHJvY2VzcygnbHMnKTtcbiAgICAgIGxldCBzdGFydCA9IERhdGUubm93KCk7XG4gICAgICBhd2FpdCBzLnN0YXJ0KHNkLCA1MDApLnNob3VsZC5ldmVudHVhbGx5LmJlLnJlamVjdGVkV2l0aCgvZGlkIG5vdCBzdGFydC4rdGltZS9pKTtcbiAgICAgIChEYXRlLm5vdygpIC0gc3RhcnQpLnNob3VsZC5iZS5iZWxvdyg2MDApO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnbGlzdGVuaW5nIGZvciBkYXRhJywgKCkgPT4ge1xuICAgIGxldCBzdWJwcm9jO1xuICAgIGl0KCdzaG91bGQgZ2V0IG91dHB1dCBhcyBwYXJhbXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShhc3luYyAocmVzb2x2ZSkgPT4ge1xuICAgICAgICBzdWJwcm9jID0gbmV3IFN1YlByb2Nlc3MoZ2V0Rml4dHVyZSgnc2xlZXB5cHJvYycpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgWydscycsIHBhdGgucmVzb2x2ZShfX2Rpcm5hbWUpXSk7XG4gICAgICAgIHN1YnByb2Mub24oJ291dHB1dCcsIChzdGRvdXQpID0+IHtcbiAgICAgICAgICBpZiAoc3Rkb3V0ICYmIHN0ZG91dC5pbmRleE9mKCdzdWJwcm9jLXNwZWNzJykgIT09IC0xKSB7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgc3VicHJvYy5zdGFydCgpO1xuICAgICAgfSk7XG4gICAgICBhd2FpdCBzdWJwcm9jLnN0b3AoKTtcblxuICAgICAgYXdhaXQgbmV3IFByb21pc2UoYXN5bmMgKHJlc29sdmUpID0+IHtcbiAgICAgICAgc3VicHJvYyA9IG5ldyBTdWJQcm9jZXNzKGdldEZpeHR1cmUoJ2VjaG8nKSwgWydmb28nLCAnYmFyJ10pO1xuICAgICAgICBzdWJwcm9jLm9uKCdvdXRwdXQnLCAoc3Rkb3V0LCBzdGRlcnIpID0+IHtcbiAgICAgICAgICBpZiAoc3RkZXJyICYmIHN0ZGVyci5pbmRleE9mKCdiYXInKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCBzdWJwcm9jLnN0YXJ0KCk7XG4gICAgICB9KTtcbiAgICAgIGF3YWl0IHN1YnByb2Muc3RvcCgpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBnZXQgb3V0cHV0IGJ5IGxpbmVzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgc3VicHJvYyA9IG5ldyBTdWJQcm9jZXNzKCdscycsIFtwYXRoLnJlc29sdmUoX19kaXJuYW1lKV0pO1xuICAgICAgbGV0IGxpbmVzID0gW107XG4gICAgICBzdWJwcm9jLm9uKCdsaW5lcy1zdGRvdXQnLCAobmV3TGluZXMpID0+IHtcbiAgICAgICAgbGluZXMgPSBsaW5lcy5jb25jYXQobmV3TGluZXMpO1xuICAgICAgfSk7XG4gICAgICBhd2FpdCBzdWJwcm9jLnN0YXJ0KDApO1xuICAgICAgYXdhaXQgQi5kZWxheSg1MCk7XG4gICAgICBsaW5lcy5zaG91bGQuZXFsKFsnZXhlYy1zcGVjcy5qcycsICdmaXh0dXJlcycsICdoZWxwZXJzLmpzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdzdWJwcm9jLXNwZWNzLmpzJ10pO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnI3N0b3AnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBzZW5kIHRoZSByaWdodCBzaWduYWwgdG8gc3RvcCBhIHByb2MnLCBhc3luYyAoKSA9PiB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoYXN5bmMgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBsZXQgc3VicHJvYyA9IG5ldyBTdWJQcm9jZXNzKCd0YWlsJywgWyctZicsIHBhdGgucmVzb2x2ZShfX2ZpbGVuYW1lKV0pO1xuICAgICAgICBhd2FpdCBzdWJwcm9jLnN0YXJ0KCk7XG4gICAgICAgIHN1YnByb2Mub24oJ2V4aXQnLCAoY29kZSwgc2lnbmFsKSA9PiB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHNpZ25hbC5zaG91bGQuZXF1YWwoc3RvcFNpZ25hbCk7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHN1YnByb2Muc3RvcChzdG9wU2lnbmFsKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCB0aW1lIG91dCBpZiBzdG9wIGRvZXNudCBjb21wbGV0ZSBmYXN0IGVub3VnaCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGxldCBzdWJwcm9jID0gbmV3IFN1YlByb2Nlc3MoZ2V0Rml4dHVyZSgndHJhcGh1cCcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbJ3RhaWwnLCAnLWYnLCBwYXRoLnJlc29sdmUoX19maWxlbmFtZSldKTtcbiAgICAgIGF3YWl0IHN1YnByb2Muc3RhcnQoKTtcbiAgICAgIGF3YWl0IHN1YnByb2Muc3RvcChzdG9wU2lnbmFsLCAxKVxuICAgICAgICAgICAgICAuc2hvdWxkLmV2ZW50dWFsbHkuYmUucmVqZWN0ZWRXaXRoKC9Qcm9jZXNzIGRpZG4ndCBlbmQvKTtcblxuICAgICAgLy8gbmVlZCB0byBraWxsIHRoZSBwcm9jZXNzXG4gICAgICAvLyAxIGZvciB0aGUgdHJhcCwgMSBmb3IgdGhlIHRhaWxcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IGV4ZWMoJ2tpbGwnLCBbJy05Jywgc3VicHJvYy5wcm9jLnBpZCArIDFdKTtcbiAgICAgIH0gY2F0Y2ggKGlnbikge31cbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IGV4ZWMoJ2tpbGwnLCBbJy05Jywgc3VicHJvYy5wcm9jLnBpZF0pO1xuICAgICAgfSBjYXRjaCAoaWduKSB7fVxuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBlcnJvciBpZiB0aGVyZSBpcyBubyBwcm9jZXNzIHRvIHN0b3AnLCBhc3luYyAoKSA9PiB7XG4gICAgICBsZXQgc3VicHJvYyA9IG5ldyBTdWJQcm9jZXNzKCdscycpO1xuICAgICAgYXdhaXQgc3VicHJvYy5zdG9wKCkuc2hvdWxkLmV2ZW50dWFsbHkuYmUucmVqZWN0ZWRXaXRoKC9DYW4ndCBzdG9wLyk7XG4gICAgICBhd2FpdCBzdWJwcm9jLnN0YXJ0KCk7XG4gICAgICBhd2FpdCBCLmRlbGF5KDEwKTtcbiAgICAgIGF3YWl0IHN1YnByb2Muc3RvcCgpLnNob3VsZC5ldmVudHVhbGx5LmJlLnJlamVjdGVkV2l0aCgvQ2FuJ3Qgc3RvcC8pO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnI2pvaW4nLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBmYWlsIGlmIHRoZSAjc3RhcnQgaGFzIG5vdCB5ZXQgYmVlbiBjYWxsZWQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBwcm9jID0gbmV3IFN1YlByb2Nlc3MoZ2V0Rml4dHVyZSgnc2xlZXB5cHJvYy5zaCcpLCBbJ2xzJ10pO1xuICAgICAgYXdhaXQgcHJvYy5qb2luKCkuc2hvdWxkLmV2ZW50dWFsbHkuYmUucmVqZWN0ZWRXaXRoKC9DYW4ndCBqb2luLyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHdhaXQgdW50aWwgdGhlIHByb2Nlc3MgaGFzIGJlZW4gZmluaXNoZWQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBwcm9jID0gbmV3IFN1YlByb2Nlc3MoZ2V0Rml4dHVyZSgnc2xlZXB5cHJvYycpLCBbJ2xzJ10pO1xuICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgIGF3YWl0IHByb2Muc3RhcnQoMCk7XG4gICAgICBhd2FpdCBwcm9jLmpvaW4oKTtcbiAgICAgIGNvbnN0IGRpZmYgPSBEYXRlLm5vdygpIC0gbm93O1xuICAgICAgZGlmZi5zaG91bGQuYmUuYWJvdmUoMTAwMCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHRocm93IGlmIHByb2Nlc3MgZW5kcyB3aXRoIGEgaW52YWxpZCBleGl0Y29kZScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHByb2MgPSBuZXcgU3ViUHJvY2VzcyhnZXRGaXh0dXJlKCdiYWRfZXhpdCcpKTtcbiAgICAgIGF3YWl0IHByb2Muc3RhcnQoMCk7XG4gICAgICBhd2FpdCBwcm9jLmpvaW4oKS5zaG91bGQuZXZlbnR1YWxseS5iZS5yZWplY3RlZFdpdGgoL1Byb2Nlc3MgZW5kZWQgd2l0aCBleGl0Y29kZS8pO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBOT1QgdGhyb3cgaWYgcHJvY2VzcyBlbmRzIHdpdGggYSBjdXN0b20gYWxsb3dlZCBleGl0Y29kZScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHByb2MgPSBuZXcgU3ViUHJvY2VzcyhnZXRGaXh0dXJlKCdiYWRfZXhpdCcpKTtcbiAgICAgIGF3YWl0IHByb2Muc3RhcnQoMCk7XG4gICAgICBhd2FpdCBwcm9jLmpvaW4oWzFdKS5zaG91bGQuZXZlbnR1YWxseS5iZS5iZWNvbWUoMSk7XG4gICAgfSk7XG4gIH0pO1xufSk7XG4iXSwic291cmNlUm9vdCI6Ii4uLy4uIn0=
