'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _Object$assign = require('babel-runtime/core-js/object/assign')['default'];

var _Promise = require('babel-runtime/core-js/promise')['default'];

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _child_process = require('child_process');

var _shellQuote = require('shell-quote');

var _events = require('events');

var _events2 = _interopRequireDefault(_events);

var _through = require('through');

var _through2 = _interopRequireDefault(_through);

var EventEmitter = _events2['default'].EventEmitter;

function exec(cmd) {
  var args = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];
  var opts = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

  // get a quoted representation of the command for error strings
  var rep = (0, _shellQuote.quote)([cmd].concat(args));

  // extend default options; we're basically re-implementing exec's options
  // for use here with spawn under the hood
  opts = _Object$assign({
    timeout: null,
    encoding: 'utf8',
    killSignal: 'SIGTERM',
    cwd: undefined,
    env: process.env,
    ignoreOutput: false,
    stdio: "inherit",
    isBuffer: false
  }, opts);

  // this is an async function, so return a promise
  return new _Promise(function (resolve, reject) {
    // spawn the child process with options; we don't currently expose any of
    // the other 'spawn' options through the API
    var proc = (0, _child_process.spawn)(cmd, args, { cwd: opts.cwd, env: opts.env });
    var stdoutArr = [],
        stderrArr = [],
        timer = null;

    // if the process errors out, reject the promise
    proc.on('error', function (err) {
      var msg = 'Command \'' + rep + '\' errored out: ' + err.stack;
      if (err.errno === 'ENOENT') {
        msg = 'Command \'' + cmd + '\' not found. Is it installed?';
      }
      reject(new Error(msg));
    });
    if (proc.stdin) {
      proc.stdin.on('error', function (err) {
        reject(new Error('Standard input \'' + err.syscall + '\' error: ' + err.stack));
      });
    }
    if (proc.stdout) {
      proc.stdout.on('error', function (err) {
        reject(new Error('Standard output \'' + err.syscall + '\' error: ' + err.stack));
      });
    }
    if (proc.stderr) {
      proc.stderr.on('error', function (err) {
        reject(new Error('Standard error \'' + err.syscall + '\' error: ' + err.stack));
      });
    }

    // keep track of stdout/stderr if we haven't said not to
    if (!opts.ignoreOutput) {
      if (proc.stdout) {
        proc.stdout.on('data', function (data) {
          stdoutArr.push(data);
        });
      }
      if (proc.stderr) {
        proc.stderr.on('data', function (data) {
          stderrArr.push(data);
        });
      }
    }

    function getStdio(isBuffer) {
      var stdout = undefined,
          stderr = undefined;
      if (isBuffer) {
        stdout = Buffer.concat(stdoutArr);
        stderr = Buffer.concat(stderrArr);
      } else {
        stdout = Buffer.concat(stdoutArr).toString(opts.encoding);
        stderr = Buffer.concat(stderrArr).toString(opts.encoding);
      }
      return { stdout: stdout, stderr: stderr };
    }

    // if the process ends, either resolve or reject the promise based on the
    // exit code of the process. either way, attach stdout, stderr, and code.
    // Also clean up the timer if it exists
    proc.on('close', function (code) {
      if (timer) {
        clearTimeout(timer);
      }

      var _getStdio = getStdio(opts.isBuffer);

      var stdout = _getStdio.stdout;
      var stderr = _getStdio.stderr;

      if (code === 0) {
        resolve({ stdout: stdout, stderr: stderr, code: code });
      } else {
        var err = new Error('Command \'' + rep + '\' exited with code ' + code);
        err = _Object$assign(err, { stdout: stdout, stderr: stderr, code: code });
        reject(err);
      }
    });

    // if we set a timeout on the child process, cut into the execution and
    // reject if the timeout is reached. Attach the stdout/stderr we currently
    // have in case it's helpful in debugging
    if (opts.timeout) {
      timer = setTimeout(function () {
        var _getStdio2 = getStdio(opts.isBuffer);

        var stdout = _getStdio2.stdout;
        var stderr = _getStdio2.stderr;

        var err = new Error('Command \'' + rep + '\' timed out after ' + opts.timeout + 'ms');
        err = _Object$assign(err, { stdout: stdout, stderr: stderr, code: null });
        reject(err);
        // reject and THEN kill to avoid race conditions with the handlers
        // above
        proc.kill(opts.killSignal);
      }, opts.timeout);
    }
  });
}

var SubProcess = (function (_EventEmitter) {
  _inherits(SubProcess, _EventEmitter);

  function SubProcess(cmd) {
    var args = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];
    var opts = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

    _classCallCheck(this, SubProcess);

    _get(Object.getPrototypeOf(SubProcess.prototype), 'constructor', this).call(this);
    if (!cmd) throw new Error("Command is required");
    if (typeof cmd !== "string") throw new Error("Command must be a string");
    if (!(args instanceof Array)) throw new Error("Args must be an array");
    this.cmd = cmd;
    this.args = args;
    this.proc = null;
    this.opts = opts;
  }

  _createClass(SubProcess, [{
    key: 'start',

    // spawn the subprocess and return control whenever we deem that it has fully
    // "started"
    value: function start() {
      var startDetector = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];
      var timeoutMs = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
      var startDelay;
      return _regeneratorRuntime.async(function start$(context$2$0) {
        var _this = this;

        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            startDelay = 10;

            // the default start detector simply returns true when we get any output
            if (startDetector === null) {
              startDetector = function (stdout, stderr) {
                return stdout || stderr;
              };
            }

            // if the user passes a number, then we simply delay a certain amount of
            // time before returning control, rather than waiting for a condition
            if (typeof startDetector === 'number') {
              startDelay = startDetector;
              startDetector = null;
            }

            // return a promise so we can wrap the async behavior
            return context$2$0.abrupt('return', new _Promise(function (resolve, reject) {
              try {
                // actually spawn the subproc
                _this.proc = (0, _child_process.spawn)(_this.cmd, _this.args, _this.opts);
              } catch (e) {
                reject(e);
              }
              if (_this.proc.stdout) {
                _this.proc.stdout.setEncoding(_this.opts.encoding || 'utf8');
              }
              if (_this.proc.stderr) {
                _this.proc.stderr.setEncoding(_this.opts.encoding || 'utf8');
              }
              _this.lastLinePortion = { stdout: "", stderr: "" };

              // this function handles output that we collect from the subproc
              var handleOutput = function handleOutput(data) {
                // if we have a startDetector, run it on the output so we can resolve/
                // reject and move on from start
                try {
                  if (startDetector && startDetector(data.stdout, data.stderr)) {
                    startDetector = null;
                    resolve();
                  }
                } catch (e) {
                  reject(e);
                }

                // emit the actual output for whomever's listening
                _this.emit('output', data.stdout, data.stderr);

                // we also want to emit lines, but it's more complex since output
                // comes in chunks and a line could come in two different chunks, so
                // we have logic to handle that case (using this.lastLinePortion to
                // remember a line that started but did not finish in the last chunk)
                var _arr = ['stdout', 'stderr'];
                for (var _i = 0; _i < _arr.length; _i++) {
                  var stream = _arr[_i];
                  if (!data[stream]) continue;
                  var lines = data[stream].split("\n");
                  if (lines.length > 1) {
                    var retLines = lines.slice(0, -1);
                    retLines[0] = _this.lastLinePortion[stream] + retLines[0];
                    _this.lastLinePortion[stream] = lines[lines.length - 1];
                    _this.emit('lines-' + stream, retLines);
                  } else {
                    _this.lastLinePortion[stream] += lines[0];
                  }
                }
              };

              // if we get an error spawning the proc, reject and clean up the proc
              _this.proc.on('error', function (err) {
                _this.proc.removeAllListeners('exit');
                _this.proc.kill('SIGINT');

                if (err.errno === 'ENOENT') {
                  err = new Error('Command \'' + _this.cmd + '\' not found. Is it installed?');
                }
                reject(err);
              });

              if (_this.proc.stdout) {
                _this.proc.stdout.pipe((0, _through2['default'])(function (stdout) {
                  handleOutput({ stdout: stdout, stderr: '' });
                }));
              }

              if (_this.proc.stderr) {
                _this.proc.stderr.pipe((0, _through2['default'])(function (stderr) {
                  handleOutput({ stdout: '', stderr: stderr });
                }));
              }

              // when the proc exits, we might still have a buffer of lines we were
              // waiting on more chunks to complete. Go ahead and emit those, then
              // re-emit the exit so a listener can handle the possibly-unexpected exit
              _this.proc.on('exit', function (code, signal) {
                _this.handleLastLines();
                _this.emit('exit', code, signal);
                _this.proc = null;
              });

              // if the user hasn't given us a startDetector, instead just resolve
              // when startDelay ms have passed
              if (!startDetector) {
                setTimeout(function () {
                  resolve();
                }, startDelay);
              }

              // if the user has given us a timeout, start the clock for rejecting
              // the promise if we take too long to start
              if (typeof timeoutMs === "number") {
                setTimeout(function () {
                  reject(new Error("The process did not start in the allotted time " + ('(' + timeoutMs + 'ms)')));
                }, timeoutMs);
              }
            }));

          case 4:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }
  }, {
    key: 'handleLastLines',
    value: function handleLastLines() {
      var _arr2 = ['stdout', 'stderr'];

      for (var _i2 = 0; _i2 < _arr2.length; _i2++) {
        var stream = _arr2[_i2];
        if (this.lastLinePortion[stream]) {
          this.emit('lines-' + stream, [this.lastLinePortion[stream]]);
          this.lastLinePortion[stream] = '';
        }
      }
    }
  }, {
    key: 'stop',
    value: function stop() {
      var signal = arguments.length <= 0 || arguments[0] === undefined ? 'SIGTERM' : arguments[0];
      var timeout = arguments.length <= 1 || arguments[1] === undefined ? 10000 : arguments[1];
      return _regeneratorRuntime.async(function stop$(context$2$0) {
        var _this2 = this;

        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            if (this.isRunning) {
              context$2$0.next = 2;
              break;
            }

            throw new Error('Can\'t stop process; it\'s not currently running (cmd: \'' + this.cmd + '\')');

          case 2:
            // make sure to emit any data in our lines buffer whenever we're done with
            // the proc
            this.handleLastLines();
            return context$2$0.abrupt('return', new _Promise(function (resolve, reject) {
              _this2.proc.on('close', resolve);
              _this2.proc.kill(signal);
              setTimeout(function () {
                reject(new Error('Process didn\'t end after ' + timeout + 'ms'));
              }, timeout);
            }));

          case 4:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }
  }, {
    key: 'join',
    value: function join() {
      var allowedExitCodes = arguments.length <= 0 || arguments[0] === undefined ? [0] : arguments[0];
      return _regeneratorRuntime.async(function join$(context$2$0) {
        var _this3 = this;

        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            if (this.isRunning) {
              context$2$0.next = 2;
              break;
            }

            throw new Error("Can't join process; it's not currently running");

          case 2:
            return context$2$0.abrupt('return', new _Promise(function (resolve, reject) {
              _this3.proc.on('exit', function (code) {
                if (allowedExitCodes.indexOf(code) === -1) {
                  reject(new Error('Process ended with exitcode ' + code));
                } else {
                  resolve(code);
                }
              });
            }));

          case 3:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }
  }, {
    key: 'isRunning',
    get: function get() {
      // presence of `proc` means we have connected and started
      return !!this.proc;
    }
  }]);

  return SubProcess;
})(EventEmitter);

exports.exec = exec;
exports.spawn = _child_process.spawn;
exports.SubProcess = SubProcess;
//# sourceMappingURL=data:application/json;charset=utf8;base64,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R0FBUyxZQUFZOztRQW1MNUIsSUFBSSxHQUFKLElBQUk7UUFBRSxLQUFLO1FBQUUsVUFBVSxHQUFWLFVBQVUiLCJmaWxlIjoibGliL3RlZW5fcHJvY2Vzcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHNwYXduIH0gZnJvbSAnY2hpbGRfcHJvY2Vzcyc7XG5pbXBvcnQgeyBxdW90ZSB9IGZyb20gJ3NoZWxsLXF1b3RlJztcbmltcG9ydCBldmVudHMgZnJvbSAnZXZlbnRzJztcbmltcG9ydCB0aHJvdWdoIGZyb20gJ3Rocm91Z2gnO1xuY29uc3QgeyBFdmVudEVtaXR0ZXIgfSA9IGV2ZW50cztcblxuZnVuY3Rpb24gZXhlYyAoY21kLCBhcmdzID0gW10sIG9wdHMgPSB7fSkge1xuICAvLyBnZXQgYSBxdW90ZWQgcmVwcmVzZW50YXRpb24gb2YgdGhlIGNvbW1hbmQgZm9yIGVycm9yIHN0cmluZ3NcbiAgbGV0IHJlcCA9IHF1b3RlKFtjbWRdLmNvbmNhdChhcmdzKSk7XG5cbiAgLy8gZXh0ZW5kIGRlZmF1bHQgb3B0aW9uczsgd2UncmUgYmFzaWNhbGx5IHJlLWltcGxlbWVudGluZyBleGVjJ3Mgb3B0aW9uc1xuICAvLyBmb3IgdXNlIGhlcmUgd2l0aCBzcGF3biB1bmRlciB0aGUgaG9vZFxuICBvcHRzID0gT2JqZWN0LmFzc2lnbih7XG4gICAgdGltZW91dDogbnVsbCxcbiAgICBlbmNvZGluZzogJ3V0ZjgnLFxuICAgIGtpbGxTaWduYWw6ICdTSUdURVJNJyxcbiAgICBjd2Q6IHVuZGVmaW5lZCxcbiAgICBlbnY6IHByb2Nlc3MuZW52LFxuICAgIGlnbm9yZU91dHB1dDogZmFsc2UsXG4gICAgc3RkaW86IFwiaW5oZXJpdFwiLFxuICAgIGlzQnVmZmVyOiBmYWxzZSxcbiAgfSwgb3B0cyk7XG5cbiAgLy8gdGhpcyBpcyBhbiBhc3luYyBmdW5jdGlvbiwgc28gcmV0dXJuIGEgcHJvbWlzZVxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIC8vIHNwYXduIHRoZSBjaGlsZCBwcm9jZXNzIHdpdGggb3B0aW9uczsgd2UgZG9uJ3QgY3VycmVudGx5IGV4cG9zZSBhbnkgb2ZcbiAgICAvLyB0aGUgb3RoZXIgJ3NwYXduJyBvcHRpb25zIHRocm91Z2ggdGhlIEFQSVxuICAgIGxldCBwcm9jID0gc3Bhd24oY21kLCBhcmdzLCB7Y3dkOiBvcHRzLmN3ZCwgZW52OiBvcHRzLmVudn0pO1xuICAgIGxldCBzdGRvdXRBcnIgPSBbXSwgc3RkZXJyQXJyID0gW10sIHRpbWVyID0gbnVsbDtcblxuICAgIC8vIGlmIHRoZSBwcm9jZXNzIGVycm9ycyBvdXQsIHJlamVjdCB0aGUgcHJvbWlzZVxuICAgIHByb2Mub24oJ2Vycm9yJywgKGVycikgPT4ge1xuICAgICAgbGV0IG1zZyA9IGBDb21tYW5kICcke3JlcH0nIGVycm9yZWQgb3V0OiAke2Vyci5zdGFja31gO1xuICAgICAgaWYgKGVyci5lcnJubyA9PT0gJ0VOT0VOVCcpIHtcbiAgICAgICAgbXNnID0gYENvbW1hbmQgJyR7Y21kfScgbm90IGZvdW5kLiBJcyBpdCBpbnN0YWxsZWQ/YDtcbiAgICAgIH1cbiAgICAgIHJlamVjdChuZXcgRXJyb3IobXNnKSk7XG4gICAgfSk7XG4gICAgaWYgKHByb2Muc3RkaW4pIHtcbiAgICAgIHByb2Muc3RkaW4ub24oJ2Vycm9yJywgKGVycikgPT4ge1xuICAgICAgICByZWplY3QobmV3IEVycm9yKGBTdGFuZGFyZCBpbnB1dCAnJHtlcnIuc3lzY2FsbH0nIGVycm9yOiAke2Vyci5zdGFja31gKSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHByb2Muc3Rkb3V0KSB7XG4gICAgICBwcm9jLnN0ZG91dC5vbignZXJyb3InLCAoZXJyKSA9PiB7XG4gICAgICAgIHJlamVjdChuZXcgRXJyb3IoYFN0YW5kYXJkIG91dHB1dCAnJHtlcnIuc3lzY2FsbH0nIGVycm9yOiAke2Vyci5zdGFja31gKSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHByb2Muc3RkZXJyKSB7XG4gICAgICBwcm9jLnN0ZGVyci5vbignZXJyb3InLCAoZXJyKSA9PiB7XG4gICAgICAgIHJlamVjdChuZXcgRXJyb3IoYFN0YW5kYXJkIGVycm9yICcke2Vyci5zeXNjYWxsfScgZXJyb3I6ICR7ZXJyLnN0YWNrfWApKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIGtlZXAgdHJhY2sgb2Ygc3Rkb3V0L3N0ZGVyciBpZiB3ZSBoYXZlbid0IHNhaWQgbm90IHRvXG4gICAgaWYgKCFvcHRzLmlnbm9yZU91dHB1dCkge1xuICAgICAgaWYgKHByb2Muc3Rkb3V0KSB7XG4gICAgICAgIHByb2Muc3Rkb3V0Lm9uKCdkYXRhJywgKGRhdGEpID0+IHtcbiAgICAgICAgICBzdGRvdXRBcnIucHVzaChkYXRhKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAocHJvYy5zdGRlcnIpIHtcbiAgICAgICAgcHJvYy5zdGRlcnIub24oJ2RhdGEnLCAoZGF0YSkgPT4ge1xuICAgICAgICAgIHN0ZGVyckFyci5wdXNoKGRhdGEpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTdGRpbyAoaXNCdWZmZXIpIHtcbiAgICAgIGxldCBzdGRvdXQsIHN0ZGVycjtcbiAgICAgIGlmIChpc0J1ZmZlcikge1xuICAgICAgICBzdGRvdXQgPSBCdWZmZXIuY29uY2F0KHN0ZG91dEFycik7XG4gICAgICAgIHN0ZGVyciA9IEJ1ZmZlci5jb25jYXQoc3RkZXJyQXJyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ZG91dCA9IEJ1ZmZlci5jb25jYXQoc3Rkb3V0QXJyKS50b1N0cmluZyhvcHRzLmVuY29kaW5nKTtcbiAgICAgICAgc3RkZXJyID0gQnVmZmVyLmNvbmNhdChzdGRlcnJBcnIpLnRvU3RyaW5nKG9wdHMuZW5jb2RpbmcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtzdGRvdXQsIHN0ZGVycn07XG4gICAgfVxuXG4gICAgLy8gaWYgdGhlIHByb2Nlc3MgZW5kcywgZWl0aGVyIHJlc29sdmUgb3IgcmVqZWN0IHRoZSBwcm9taXNlIGJhc2VkIG9uIHRoZVxuICAgIC8vIGV4aXQgY29kZSBvZiB0aGUgcHJvY2Vzcy4gZWl0aGVyIHdheSwgYXR0YWNoIHN0ZG91dCwgc3RkZXJyLCBhbmQgY29kZS5cbiAgICAvLyBBbHNvIGNsZWFuIHVwIHRoZSB0aW1lciBpZiBpdCBleGlzdHNcbiAgICBwcm9jLm9uKCdjbG9zZScsIChjb2RlKSA9PiB7XG4gICAgICBpZiAodGltZXIpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgIH1cbiAgICAgIGxldCB7c3Rkb3V0LCBzdGRlcnJ9ID0gZ2V0U3RkaW8ob3B0cy5pc0J1ZmZlcik7XG4gICAgICBpZiAoY29kZSA9PT0gMCkge1xuICAgICAgICByZXNvbHZlKHtzdGRvdXQsIHN0ZGVyciwgY29kZX0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IGVyciA9IG5ldyBFcnJvcihgQ29tbWFuZCAnJHtyZXB9JyBleGl0ZWQgd2l0aCBjb2RlICR7Y29kZX1gKTtcbiAgICAgICAgZXJyID0gT2JqZWN0LmFzc2lnbihlcnIsIHtzdGRvdXQsIHN0ZGVyciwgY29kZX0pO1xuICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIGlmIHdlIHNldCBhIHRpbWVvdXQgb24gdGhlIGNoaWxkIHByb2Nlc3MsIGN1dCBpbnRvIHRoZSBleGVjdXRpb24gYW5kXG4gICAgLy8gcmVqZWN0IGlmIHRoZSB0aW1lb3V0IGlzIHJlYWNoZWQuIEF0dGFjaCB0aGUgc3Rkb3V0L3N0ZGVyciB3ZSBjdXJyZW50bHlcbiAgICAvLyBoYXZlIGluIGNhc2UgaXQncyBoZWxwZnVsIGluIGRlYnVnZ2luZ1xuICAgIGlmIChvcHRzLnRpbWVvdXQpIHtcbiAgICAgIHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGxldCB7c3Rkb3V0LCBzdGRlcnJ9ID0gZ2V0U3RkaW8ob3B0cy5pc0J1ZmZlcik7XG4gICAgICAgIGxldCBlcnIgPSBuZXcgRXJyb3IoYENvbW1hbmQgJyR7cmVwfScgdGltZWQgb3V0IGFmdGVyICR7b3B0cy50aW1lb3V0fW1zYCk7XG4gICAgICAgIGVyciA9IE9iamVjdC5hc3NpZ24oZXJyLCB7c3Rkb3V0LCBzdGRlcnIsIGNvZGU6IG51bGx9KTtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIC8vIHJlamVjdCBhbmQgVEhFTiBraWxsIHRvIGF2b2lkIHJhY2UgY29uZGl0aW9ucyB3aXRoIHRoZSBoYW5kbGVyc1xuICAgICAgICAvLyBhYm92ZVxuICAgICAgICBwcm9jLmtpbGwob3B0cy5raWxsU2lnbmFsKTtcbiAgICAgIH0sIG9wdHMudGltZW91dCk7XG4gICAgfVxuICB9KTtcbn1cblxuY2xhc3MgU3ViUHJvY2VzcyBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yIChjbWQsIGFyZ3MgPSBbXSwgb3B0cyA9IHt9KSB7XG4gICAgc3VwZXIoKTtcbiAgICBpZiAoIWNtZCkgdGhyb3cgbmV3IEVycm9yKFwiQ29tbWFuZCBpcyByZXF1aXJlZFwiKTtcbiAgICBpZiAodHlwZW9mIGNtZCAhPT0gXCJzdHJpbmdcIikgdGhyb3cgbmV3IEVycm9yKFwiQ29tbWFuZCBtdXN0IGJlIGEgc3RyaW5nXCIpO1xuICAgIGlmICghKGFyZ3MgaW5zdGFuY2VvZiBBcnJheSkpIHRocm93IG5ldyBFcnJvcihcIkFyZ3MgbXVzdCBiZSBhbiBhcnJheVwiKTtcbiAgICB0aGlzLmNtZCA9IGNtZDtcbiAgICB0aGlzLmFyZ3MgPSBhcmdzO1xuICAgIHRoaXMucHJvYyA9IG51bGw7XG4gICAgdGhpcy5vcHRzID0gb3B0cztcbiAgfVxuXG4gIGdldCBpc1J1bm5pbmcgKCkge1xuICAgIC8vIHByZXNlbmNlIG9mIGBwcm9jYCBtZWFucyB3ZSBoYXZlIGNvbm5lY3RlZCBhbmQgc3RhcnRlZFxuICAgIHJldHVybiAhIXRoaXMucHJvYztcbiAgfVxuXG4gIC8vIHNwYXduIHRoZSBzdWJwcm9jZXNzIGFuZCByZXR1cm4gY29udHJvbCB3aGVuZXZlciB3ZSBkZWVtIHRoYXQgaXQgaGFzIGZ1bGx5XG4gIC8vIFwic3RhcnRlZFwiXG4gIGFzeW5jIHN0YXJ0IChzdGFydERldGVjdG9yID0gbnVsbCwgdGltZW91dE1zID0gbnVsbCkge1xuICAgIGxldCBzdGFydERlbGF5ID0gMTA7XG5cbiAgICAvLyB0aGUgZGVmYXVsdCBzdGFydCBkZXRlY3RvciBzaW1wbHkgcmV0dXJucyB0cnVlIHdoZW4gd2UgZ2V0IGFueSBvdXRwdXRcbiAgICBpZiAoc3RhcnREZXRlY3RvciA9PT0gbnVsbCkge1xuICAgICAgc3RhcnREZXRlY3RvciA9IChzdGRvdXQsIHN0ZGVycikgPT4ge1xuICAgICAgICByZXR1cm4gc3Rkb3V0IHx8IHN0ZGVycjtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gaWYgdGhlIHVzZXIgcGFzc2VzIGEgbnVtYmVyLCB0aGVuIHdlIHNpbXBseSBkZWxheSBhIGNlcnRhaW4gYW1vdW50IG9mXG4gICAgLy8gdGltZSBiZWZvcmUgcmV0dXJuaW5nIGNvbnRyb2wsIHJhdGhlciB0aGFuIHdhaXRpbmcgZm9yIGEgY29uZGl0aW9uXG4gICAgaWYgKHR5cGVvZiBzdGFydERldGVjdG9yID09PSAnbnVtYmVyJykge1xuICAgICAgc3RhcnREZWxheSA9IHN0YXJ0RGV0ZWN0b3I7XG4gICAgICBzdGFydERldGVjdG9yID0gbnVsbDtcbiAgICB9XG5cbiAgICAvLyByZXR1cm4gYSBwcm9taXNlIHNvIHdlIGNhbiB3cmFwIHRoZSBhc3luYyBiZWhhdmlvclxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBhY3R1YWxseSBzcGF3biB0aGUgc3VicHJvY1xuICAgICAgICB0aGlzLnByb2MgPSBzcGF3bih0aGlzLmNtZCwgdGhpcy5hcmdzLCB0aGlzLm9wdHMpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5wcm9jLnN0ZG91dCkge1xuICAgICAgICB0aGlzLnByb2Muc3Rkb3V0LnNldEVuY29kaW5nKHRoaXMub3B0cy5lbmNvZGluZyB8fCAndXRmOCcpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMucHJvYy5zdGRlcnIpIHtcbiAgICAgICAgdGhpcy5wcm9jLnN0ZGVyci5zZXRFbmNvZGluZyh0aGlzLm9wdHMuZW5jb2RpbmcgfHwgJ3V0ZjgnKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubGFzdExpbmVQb3J0aW9uID0ge3N0ZG91dDogXCJcIiwgc3RkZXJyOiBcIlwifTtcblxuICAgICAgLy8gdGhpcyBmdW5jdGlvbiBoYW5kbGVzIG91dHB1dCB0aGF0IHdlIGNvbGxlY3QgZnJvbSB0aGUgc3VicHJvY1xuICAgICAgY29uc3QgaGFuZGxlT3V0cHV0ID0gKGRhdGEpID0+IHtcbiAgICAgICAgLy8gaWYgd2UgaGF2ZSBhIHN0YXJ0RGV0ZWN0b3IsIHJ1biBpdCBvbiB0aGUgb3V0cHV0IHNvIHdlIGNhbiByZXNvbHZlL1xuICAgICAgICAvLyByZWplY3QgYW5kIG1vdmUgb24gZnJvbSBzdGFydFxuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChzdGFydERldGVjdG9yICYmIHN0YXJ0RGV0ZWN0b3IoZGF0YS5zdGRvdXQsIGRhdGEuc3RkZXJyKSkge1xuICAgICAgICAgICAgc3RhcnREZXRlY3RvciA9IG51bGw7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZW1pdCB0aGUgYWN0dWFsIG91dHB1dCBmb3Igd2hvbWV2ZXIncyBsaXN0ZW5pbmdcbiAgICAgICAgdGhpcy5lbWl0KCdvdXRwdXQnLCBkYXRhLnN0ZG91dCwgZGF0YS5zdGRlcnIpO1xuXG4gICAgICAgIC8vIHdlIGFsc28gd2FudCB0byBlbWl0IGxpbmVzLCBidXQgaXQncyBtb3JlIGNvbXBsZXggc2luY2Ugb3V0cHV0XG4gICAgICAgIC8vIGNvbWVzIGluIGNodW5rcyBhbmQgYSBsaW5lIGNvdWxkIGNvbWUgaW4gdHdvIGRpZmZlcmVudCBjaHVua3MsIHNvXG4gICAgICAgIC8vIHdlIGhhdmUgbG9naWMgdG8gaGFuZGxlIHRoYXQgY2FzZSAodXNpbmcgdGhpcy5sYXN0TGluZVBvcnRpb24gdG9cbiAgICAgICAgLy8gcmVtZW1iZXIgYSBsaW5lIHRoYXQgc3RhcnRlZCBidXQgZGlkIG5vdCBmaW5pc2ggaW4gdGhlIGxhc3QgY2h1bmspXG4gICAgICAgIGZvciAobGV0IHN0cmVhbSBvZiBbJ3N0ZG91dCcsICdzdGRlcnInXSkge1xuICAgICAgICAgIGlmICghZGF0YVtzdHJlYW1dKSBjb250aW51ZTtcbiAgICAgICAgICBsZXQgbGluZXMgPSBkYXRhW3N0cmVhbV0uc3BsaXQoXCJcXG5cIik7XG4gICAgICAgICAgaWYgKGxpbmVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGxldCByZXRMaW5lcyA9IGxpbmVzLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgICAgIHJldExpbmVzWzBdID0gdGhpcy5sYXN0TGluZVBvcnRpb25bc3RyZWFtXSArIHJldExpbmVzWzBdO1xuICAgICAgICAgICAgdGhpcy5sYXN0TGluZVBvcnRpb25bc3RyZWFtXSA9IGxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgdGhpcy5lbWl0KGBsaW5lcy0ke3N0cmVhbX1gLCByZXRMaW5lcyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubGFzdExpbmVQb3J0aW9uW3N0cmVhbV0gKz0gbGluZXNbMF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvLyBpZiB3ZSBnZXQgYW4gZXJyb3Igc3Bhd25pbmcgdGhlIHByb2MsIHJlamVjdCBhbmQgY2xlYW4gdXAgdGhlIHByb2NcbiAgICAgIHRoaXMucHJvYy5vbignZXJyb3InLCBlcnIgPT4ge1xuICAgICAgICB0aGlzLnByb2MucmVtb3ZlQWxsTGlzdGVuZXJzKCdleGl0Jyk7XG4gICAgICAgIHRoaXMucHJvYy5raWxsKCdTSUdJTlQnKTtcblxuICAgICAgICBpZiAoZXJyLmVycm5vID09PSAnRU5PRU5UJykge1xuICAgICAgICAgIGVyciA9IG5ldyBFcnJvcihgQ29tbWFuZCAnJHt0aGlzLmNtZH0nIG5vdCBmb3VuZC4gSXMgaXQgaW5zdGFsbGVkP2ApO1xuICAgICAgICB9XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgfSk7XG5cbiAgICAgIGlmICh0aGlzLnByb2Muc3Rkb3V0KSB7XG4gICAgICAgIHRoaXMucHJvYy5zdGRvdXQucGlwZSh0aHJvdWdoKHN0ZG91dCA9PiB7XG4gICAgICAgICAgaGFuZGxlT3V0cHV0KHtzdGRvdXQsIHN0ZGVycjogJyd9KTtcbiAgICAgICAgfSkpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5wcm9jLnN0ZGVycikge1xuICAgICAgICB0aGlzLnByb2Muc3RkZXJyLnBpcGUodGhyb3VnaChzdGRlcnIgPT4ge1xuICAgICAgICAgIGhhbmRsZU91dHB1dCh7c3Rkb3V0OiAnJywgc3RkZXJyfSk7XG4gICAgICAgIH0pKTtcbiAgICAgIH1cblxuICAgICAgLy8gd2hlbiB0aGUgcHJvYyBleGl0cywgd2UgbWlnaHQgc3RpbGwgaGF2ZSBhIGJ1ZmZlciBvZiBsaW5lcyB3ZSB3ZXJlXG4gICAgICAvLyB3YWl0aW5nIG9uIG1vcmUgY2h1bmtzIHRvIGNvbXBsZXRlLiBHbyBhaGVhZCBhbmQgZW1pdCB0aG9zZSwgdGhlblxuICAgICAgLy8gcmUtZW1pdCB0aGUgZXhpdCBzbyBhIGxpc3RlbmVyIGNhbiBoYW5kbGUgdGhlIHBvc3NpYmx5LXVuZXhwZWN0ZWQgZXhpdFxuICAgICAgdGhpcy5wcm9jLm9uKCdleGl0JywgKGNvZGUsIHNpZ25hbCkgPT4ge1xuICAgICAgICB0aGlzLmhhbmRsZUxhc3RMaW5lcygpO1xuICAgICAgICB0aGlzLmVtaXQoJ2V4aXQnLCBjb2RlLCBzaWduYWwpO1xuICAgICAgICB0aGlzLnByb2MgPSBudWxsO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIGlmIHRoZSB1c2VyIGhhc24ndCBnaXZlbiB1cyBhIHN0YXJ0RGV0ZWN0b3IsIGluc3RlYWQganVzdCByZXNvbHZlXG4gICAgICAvLyB3aGVuIHN0YXJ0RGVsYXkgbXMgaGF2ZSBwYXNzZWRcbiAgICAgIGlmICghc3RhcnREZXRlY3Rvcikge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0sIHN0YXJ0RGVsYXkpO1xuICAgICAgfVxuXG4gICAgICAvLyBpZiB0aGUgdXNlciBoYXMgZ2l2ZW4gdXMgYSB0aW1lb3V0LCBzdGFydCB0aGUgY2xvY2sgZm9yIHJlamVjdGluZ1xuICAgICAgLy8gdGhlIHByb21pc2UgaWYgd2UgdGFrZSB0b28gbG9uZyB0byBzdGFydFxuICAgICAgaWYgKHR5cGVvZiB0aW1lb3V0TXMgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIlRoZSBwcm9jZXNzIGRpZCBub3Qgc3RhcnQgaW4gdGhlIGFsbG90dGVkIHRpbWUgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgYCgke3RpbWVvdXRNc31tcylgKSk7XG4gICAgICAgIH0sIHRpbWVvdXRNcyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBoYW5kbGVMYXN0TGluZXMgKCkge1xuICAgIGZvciAobGV0IHN0cmVhbSBvZiBbJ3N0ZG91dCcsICdzdGRlcnInXSkge1xuICAgICAgaWYgKHRoaXMubGFzdExpbmVQb3J0aW9uW3N0cmVhbV0pIHtcbiAgICAgICAgdGhpcy5lbWl0KGBsaW5lcy0ke3N0cmVhbX1gLCBbdGhpcy5sYXN0TGluZVBvcnRpb25bc3RyZWFtXV0pO1xuICAgICAgICB0aGlzLmxhc3RMaW5lUG9ydGlvbltzdHJlYW1dID0gJyc7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgc3RvcCAoc2lnbmFsID0gJ1NJR1RFUk0nLCB0aW1lb3V0ID0gMTAwMDApIHtcbiAgICBpZiAoIXRoaXMuaXNSdW5uaW5nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbid0IHN0b3AgcHJvY2VzczsgaXQncyBub3QgY3VycmVudGx5IHJ1bm5pbmcgKGNtZDogJyR7dGhpcy5jbWR9JylgKTtcbiAgICB9XG4gICAgLy8gbWFrZSBzdXJlIHRvIGVtaXQgYW55IGRhdGEgaW4gb3VyIGxpbmVzIGJ1ZmZlciB3aGVuZXZlciB3ZSdyZSBkb25lIHdpdGhcbiAgICAvLyB0aGUgcHJvY1xuICAgIHRoaXMuaGFuZGxlTGFzdExpbmVzKCk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMucHJvYy5vbignY2xvc2UnLCByZXNvbHZlKTtcbiAgICAgIHRoaXMucHJvYy5raWxsKHNpZ25hbCk7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihgUHJvY2VzcyBkaWRuJ3QgZW5kIGFmdGVyICR7dGltZW91dH1tc2ApKTtcbiAgICAgIH0sIHRpbWVvdXQpO1xuICAgIH0pO1xuICB9XG5cbiAgYXN5bmMgam9pbiAoYWxsb3dlZEV4aXRDb2RlcyA9IFswXSkge1xuICAgIGlmICghdGhpcy5pc1J1bm5pbmcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IGpvaW4gcHJvY2VzczsgaXQncyBub3QgY3VycmVudGx5IHJ1bm5pbmdcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMucHJvYy5vbignZXhpdCcsIChjb2RlKSA9PiB7XG4gICAgICAgIGlmIChhbGxvd2VkRXhpdENvZGVzLmluZGV4T2YoY29kZSkgPT09IC0xKSB7XG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihgUHJvY2VzcyBlbmRlZCB3aXRoIGV4aXRjb2RlICR7Y29kZX1gKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzb2x2ZShjb2RlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0IHsgZXhlYywgc3Bhd24sIFN1YlByb2Nlc3MgfTtcbiJdLCJzb3VyY2VSb290IjoiLi4vLi4ifQ==
